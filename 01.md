NIP-01
======

基本的なプロトコルフローの説明
-------------------------------

`draft` `mandatory`

このNIPは、誰もが実装すべき基本的なプロトコルを定義する。新しいNIPによって、新たにオプショナルな（もしくは必須の）フィールド・メッセージ・機能が、ここで記述される構造やフローに追加される可能性がある。

## イベントと署名

ユーザーは各々が鍵ペアを持つ。署名、公開鍵、エンコーディングは[Schnorr signatures standard for the curve `secp256k1` （`secp256k1`曲線シュノア署名標準）](https://bips.xyz/340)に従う。

ただ1つだけ存在するオブジェクトの型が `event` で、以下のようなフォーマットで伝送される。

```json
{
  "id": <32-bytes lowercase hex-encoded sha256 of the serialized event data>,
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": <integer between 0 and 65535>,
  "tags": [
    [<arbitrary string>...],
    ...
  ],
  "content": <arbitrary string>,
  "sig": <64-bytes lowercase hex of the signature of the sha256 hash of the serialized event data, which is the same as the "id" field>
}
```

`event.id`を得るため、そのイベントをシリアライズして`sha256`を計算する。具体的には、以下の構造をUTF-8 JSON文字列（フィールド間にはホワイトスペースや改行を含めない）としてシリアライズすることで行う。

```
[
  0,
  <pubkey, as a lowercase hex string>,
  <created_at, as a number>,
  <kind, as a number>,
  <tags, as an array of arrays of non-null strings>,
  <content, as a string>
]
```

### タグ

タグはそれぞれ任意長の文字列の配列で、関連していくつかの慣例がある。以下の例を見てみよう。

```json
{
  ...,
  "tags": [
    ["e", "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36", "wss://nostr.example.com"],
    ["p", "f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca"],
    ["a", "30023:f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca:abcd", "wss://nostr.example.com"],
    ["alt", "reply"],
    ...
  ],
  ...
}
```

タグ配列の最初の要素をタグの _名前_ または _キー_ と呼び、2番目をタグの _値_ と呼ぶ。したがって、上のイベントでは`e`タグが`"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"`に設定されていて、`alt`タグが`"reply"`に設定されている、などと言える。2番目より後の要素には慣用的な呼び方はない。

このNIPでは標準的なタグを3つ定義する。これらのタグは、あらゆるイベントのkindにおいて同じ意味で用いられる。以下の通りだ。

- `e` タグ。イベントを参照するために用いる： `["e", <他のイベントIDの32バイト小文字16進数文字列>, <おすすめのリレーURL、省略可能>]`
- `p` タグ。別のユーザを参照するために用いる： `["p", <pubkeyの32バイト小文字16進数文字列>, <おすすめのリレーURL、省略可能>]`
- `a` タグ。（パラメータ付き・無し）置換可能イベントを参照するために用いる。
  -  パラメータ付き置換可能イベントの場合: `["a", <kind整数>:<pubkeyの32バイト小文字16進数文字列>:<dタグの値>, <おすすめリレーURL、省略可能>]`
  -  パラメータ無し置換可能イベントの場合: `["a", <kind整数>:<pubkeyの32バイト小文字16進数文字列>:, <おすすめリレーURL、省略可能>]`

慣例として、全ての1文字（英語のアルファベットa-zとA-Zに限る）キーをもつタグは、リレーによってインデクスされることが期待される。これにより、例えば、イベント`"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"`を参照しているイベントをクエリしたり購読するために、`{"#e": "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"}`フィルタを使える。

### Kinds

Kindはクライアントがイベントやイベントのフィールドをどう解釈すべきかを決める（たとえば、`"r"`タグのkind 1における意味は、kind 10002のイベントにおける意味と全く異なる可能性がある）。それぞれのNIPにおいて、他の場所で定義されていないkindの意味を定義する可能性がある。このNIPでは、以下のように2つの基本的なkindを定義する。

- `0`: **メタデータ**: `content`は文字列化されたJSONオブジェクト`{name: <ユーザ名>, about: <文字列>, picture: <URL、文字列>}`で、イベントを作成したユーザのことを記述する。リレーは、同一のpubkeyから新しいイベントを受信した際、過去のイベントを削除できる。
- `1`: **テキスト投稿**: `content`はノート（ユーザが発言したいこと）を**プレーンテキスト**で指定する。パースが必要なコンテンツ（マークダウンやHTMLなど）を使用すべきではない。クライアントもコンテンツをそのようにパースをしてはならない。

実験を容易にし、リレーの実装を柔軟にするため、kindの範囲についての以下のような慣例もある。

- kind `n` が範囲 `1000 <= n < 10000` の場合は、イベントは**通常（regular）**で、全てがリレーに保存されることが期待される。
- kind `n` が範囲 `10000 <= n < 20000 || n == 0 || n == 3` の場合は、イベントは**置換可能（replaceable）**で、最新のイベントだけがリレーに保持されなければならない（MUST）。また、古いバージョンは破棄してもかまわない（MAY）。
- kind `n` が範囲 `20000 <= n < 30000` の場合は、イベントは**一時的（ephemeral）**で、リレーに保存されないことが期待される。
- kind `n` が範囲 `30000 <= n < 40000` の場合は、イベントは**パラメータ付き置換可能（parameterized replaceable）**で、`pubkey`と`kind`と`d`タグの最初の値の組み合わせについて、最新のイベントのみがリレーに保存されなければならない（MUST）。また、古いバージョンは破棄してかまわない（MAY）。

置換可能イベントが同じタイムスタンプを持っている場合は、最も小さいID（辞書順で最初）のイベントが保持され、他のイベントは破棄されるべきだ。

置換可能イベントに対する`REQ`メッセージ（たとえば`{"kinds":[0],"authors":[<hex-key>]}`）に応答する場合には、リレーが仮に複数のバージョンを保持していたとしても、最新の１つだけを返すべきだ（SHOULD）。

これらは単なる慣例にすぎず、リレーの実装は異なる可能性がある。

## クライアントとリレー間の通信

リレーは、クライアントが接続するためのWebSocketエンドポイントを公開する。クライアントは１つのリレーに対して１つだけWebSocketコネクションを開き、全ての購読でそれを使うべきだ（SHOULD）。リレーは特定のIP、クライアント、その他によってコネクション数を制限してもかまわない（MAY）。

### クライアントからリレーへ：イベントの送信と購読の作成

クライアントは3種類のメッセージを送信できる。メッセージはJSON配列で、以下のパターンでなければならない。

  * `["EVENT", <前述のイベントJSON>]` イベントを送信するために使う。
  * `["REQ", <購読ID>, <フィルタJSON>...]` イベントを要求し、更新を購読するために使う。
  * `["CLOSE", <購読ID>]` 既存の購読を中止するために使う。

`<購読ID>` は任意の、空でない最大64文字の文字列で、購読を区別するために用いる。リレーはWebSocket接続ごとに独立して`<購読ID>`を管理しなければならない。同一文字列の`<購読ID>`でも、コネクションごとに異なる購読として扱うべきだ。

`<フィルタ>` はJSONオブジェクトで、どんなイベントがその購読で転送されるかを決める。以下の属性をもつ可能性がある。

```json
{
  "ids": <a list of event ids>,
  "authors": <a list of lowercase pubkeys, the pubkey of an event must be one of these>,
  "kinds": <a list of a kind numbers>,
  "#<single-letter (a-zA-Z)>": <a list of tag values, for #e — a list of event ids, for #p — a list of event pubkeys etc>,
  "since": <an integer unix timestamp in seconds, events must be newer than this to pass>,
  "until": <an integer unix timestamp in seconds, events must be older than this to pass>,
  "limit": <maximum number of events relays SHOULD return in the initial query>
}
```

`REQ`メッセージを受信すると、リレーは内部データベースに問い合わせてフィルターにマッチするイベントを返し、そのフィルターを保存しておいて、以降に受信した全てのイベントをWebSocketがクローズされるまで同じWebSocketに送信すべきだ（SHOULD）。同一の`<購読ID>`を持つ`CLOSE`イベントを受信するか、同一の`<購読ID>`を使って新たな`REQ`が送信されると、リレーは既存の購読を更新しなければならない（MUST）。

リストをとるフィルター属性（`ids`、`authors`、`kind`と`#e`のようなタグフィルタ）は、1つ以上の要素を持つJSON配列である。その条件がマッチしたとみなされるためには、配列の値のうち少なくとも1つがイベントの関連するフィールドと一致しなければならない。`authors`や`kind`のようなスカラーのイベント属性の場合は、イベントの属性値がフィルターのリストに含まれなければならない。`#e`などのタグ属性のように、イベントが複数の値を持ちうる場合は、イベントとフィルタの条件値が少なくとも1つの共通する要素を持たなければならない。

`ids`、`authors`、`#e`、`#p`のフィルタのリストが要素として含むのは、64文字の小文字の16進数文字列でなければならない（MUST）。

`since`と`unitl`プロパティは、購読で返されるイベントの時刻の範囲を指定するために使用できる。もし、フィルタに`since`プロパティがあれば、`since`以上の`created_at`を持つイベントがマッチする。`until`プロパティも同様で、`until`以下の`created_at`を持つイベントがマッチする。つまり、条件 `since <= created_at <= until` が満たされるとき、イベントがフィルタにマッチする。

イベントがあるフィルタを通過するためには、フィルタに指定された全ての条件がマッチしなければならない。つまり、複数の条件は`&&`条件として解釈される。

1つの`REQ`メッセージに複数のフィルタを含むことができる。この場合、いずれかのフィルタにマッチするイベントが返される。つまり、複数のフィルタは`||`条件として解釈される。

フィルタの`limit`プロパティは、初期クエリにのみ影響を及ぼし、それ以降は無視されなければならない（MUST）。`limit: n`が存在する場合、初期クエリでは最新の`n`イベントが`created_at`順に返されることが想定される。`limit`の指定よりも少ないイベントを返すことは問題ない。しかし、クライアントに対して不必要に負荷を与えることを避けるため、リレーは要求されたよりも（はるかに）多くのイベントを返すことがないよう期待される。

### リレーからクライアントへ：イベントの送信と通知

リレーは4種類のメッセージを送信できる。メッセージはJSON配列で、以下のパターンでなければならない。

<<<<<<< HEAD
  * `["EVENT", <購読ID>, <前述のイベントJSON>]` クライアントから要求されたイベントを送信するために使う。
  * `["OK", <イベントID>, <true|false>, <メッセージ>]` `EVENT`メッセージの受理または拒否を通知するために使う。
  * `["EOSE", <購読ID>]` 保存されているイベントの終わり（End Of Stored Events）、リアルタイムに受信されたイベントの開始を示す。
  * `["NOTICE", <メッセージ>]` 人間可読なエラーメッセージやその他の事柄をクライアントへ送信するために使う。
=======
  * `["EVENT", <subscription_id>, <event JSON as defined above>]`, used to send events requested by clients.
  * `["OK", <event_id>, <true|false>, <message>]`, used to indicate acceptance or denial of an `EVENT` message.
  * `["EOSE", <subscription_id>]`, used to indicate the _end of stored events_ and the beginning of events newly received in real-time.
  * `["CLOSED", <subscription_id>, <message>]`, used to indicate that a subscription was ended on the server side.
  * `["NOTICE", <message>]`, used to send human-readable error messages or other things to clients.
>>>>>>> upstream/master

このNIPでは`NOTICE`メッセージをどのように送信し、またどのように扱うべきかについてのルールは定義しない。

<<<<<<< HEAD
- `EVENT`メッセージは、クライアントが（前述の`REQ`メッセージを用いて）以前に開始した購読IDと紐付けられたものだけが送信されなければならない（MUST）。
- `OK`メッセージは、クライアントから受信した`EVENT`メッセージに対する返信として送信されなければならない（MUST）。3番目のパラメータは、リレーがメッセージを受理する場合は`ture`を、そうでなければ`false`を指定しなければならない。4番目のパラメータも必須で（MUST）、3番目が`true`の場合は空文字列でもかまわない（MAY）が、そうでなければ、機械可読な一語のプレフィクスに続けて`:`と人間可読なメッセージを含まなければならない（MUST）。標準化されている機械可読なプレフィクスは、`duplicate`、`pow`、`blocked`、`rate-limited`、`invalid`と`error`（他のどれにも当てはまらない場合）だ。例は以下の通りだ。

  * `["OK", "b1a649ebe8...", true, ""]`
  * `["OK", "b1a649ebe8...", true, "pow: difficulty 25>=24"]` pow: 難易度25は24以上
  * `["OK", "b1a649ebe8...", true, "duplicate: already have this event"]` 重複: すでにこのイベントは存在している
  * `["OK", "b1a649ebe8...", false, "blocked: you are banned from posting here"]` ブロックされている: あなたはここで投稿することが禁止されている
  * `["OK", "b1a649ebe8...", false, "blocked: please register your pubkey at https://my-expensive-relay.example.com"]` ブロックされている: https://my-expensive-relay.example.comでpubkeyを登録せよ
  * `["OK", "b1a649ebe8...", false, "rate-limited: slow down there chief"]` レートリミット: ゆっくりしなさい
  * `["OK", "b1a649ebe8...", false, "invalid: event creation date is too far off from the current time. Is your system clock in sync?"]` 無効: イベント作成日が現在時刻から大きくずれている。システムクロックは同期されているか？
  * `["OK", "b1a649ebe8...", false, "pow: difficulty 26 is less than 30"]` pow: 難易度26は30よりも小さい
  * `["OK", "b1a649ebe8...", false, "error: could not connect to the database"]` エラー: データベースに接続できなかった
=======
- `EVENT` messages MUST be sent only with a subscription ID related to a subscription previously initiated by the client (using the `REQ` message above).
- `OK` messages MUST be sent in response to `EVENT` messages received from clients, they must have the 3rd parameter set to `true` when an event has been accepted by the relay, `false` otherwise. The 4th parameter MUST always be present, but MAY be an empty string when the 3rd is `true`, otherwise it MUST be a string formed by a machine-readable single-word prefix followed by a `:` and then a human-readable message. Some examples:
  * `["OK", "b1a649ebe8...", true, ""]`
  * `["OK", "b1a649ebe8...", true, "pow: difficulty 25>=24"]`
  * `["OK", "b1a649ebe8...", true, "duplicate: already have this event"]`
  * `["OK", "b1a649ebe8...", false, "blocked: you are banned from posting here"]`
  * `["OK", "b1a649ebe8...", false, "blocked: please register your pubkey at https://my-expensive-relay.example.com"]`
  * `["OK", "b1a649ebe8...", false, "rate-limited: slow down there chief"]`
  * `["OK", "b1a649ebe8...", false, "invalid: event creation date is too far off from the current time"]`
  * `["OK", "b1a649ebe8...", false, "pow: difficulty 26 is less than 30"]`
  * `["OK", "b1a649ebe8...", false, "error: could not connect to the database"]`
- `CLOSED` messages MUST be sent in response to a `REQ` when the relay refuses to fulfill it. It can also be sent when a relay decides to kill a subscription on its side before a client has disconnected or sent a `CLOSE`. This message uses the same pattern of `OK` messages with the machine-readable prefix and human-readable message. Some examples:
  * `["CLOSED", "sub1", "duplicate: sub1 already opened"]`
  * `["CLOSED", "sub1", "unsupported: filter contains unknown elements"]`
  * `["CLOSED", "sub1", "error: could not connect to the database"]`
  * `["CLOSED", "sub1", "error: shutting down idle subscription"]`
- The standardized machine-readable prefixes for `OK` and `CLOSED` are: `duplicate`, `pow`, `blocked`, `rate-limited`, `invalid`, and `error` for when none of that fits.
>>>>>>> upstream/master
